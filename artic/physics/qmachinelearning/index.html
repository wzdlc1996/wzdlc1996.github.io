<!DOCTYPE html>
<html lang="zh_Hans">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, maximum-scale=1" />
  
  <meta name="author" content="Leonard">
  <meta name="description" content="Quantum machine learning is the integration of quantum algorithms within machine learning programs. Generally, we have four different approaches for this purpose, by the type of data (quantum state/data or classical data) and type of algorithm or platform (quantum algorithm/computer or classical algorithm/computer). In this report, we focus on an elementary discussion about aspect of the quantum approach to classical data. The more attractive part about quantum approach to quantum data will be left for future posts.">

  <meta property="og:title" content="Quantum Machine Learning: Quantum Algorithms to Classical Data" />
<meta property="og:description" content="Quantum machine learning is the integration of quantum algorithms within machine learning programs. Generally, we have four different approaches for this purpose, by the type of data (quantum state/data or classical data) and type of algorithm or platform (quantum algorithm/computer or classical algorithm/computer). In this report, we focus on an elementary discussion about aspect of the quantum approach to classical data. The more attractive part about quantum approach to quantum data will be left for future posts." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wzdlc1996.github.io/artic/physics/qmachinelearning/" /><meta property="article:section" content="Artic" />
<meta property="article:published_time" content="2020-12-19T14:16:00+08:00" />
<meta property="article:modified_time" content="2020-02-10T18:00:00+08:00" />



  <title>
    
     Quantum Machine Learning: Quantum Algorithms to Classical Data | Leonard 
    
  </title>

  <link rel="canonical" href="https://wzdlc1996.github.io/artic/physics/qmachinelearning/">

  
  

  
  <link href="https://wzdlc1996.github.io/css/vendors-extensions/fontawesome/all.min.css" rel="stylesheet">

  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700|Ubuntu+Mono:400,400i,700,700i|Raleway:300,400,500,600">
  <link href="https://wzdlc1996.github.io/css/font.css" rel="stylesheet">

  
  <link href="https://wzdlc1996.github.io/css/vendors/bootstrap4/bootstrap.min.css" rel="stylesheet">
  <link href="https://wzdlc1996.github.io/css/vendors-extensions/mdb/mdb.min.css" rel="stylesheet">
  <link href="https://wzdlc1996.github.io/css/vendors/mdb/style.min.css" rel="stylesheet">
  <link href="https://wzdlc1996.github.io/css/vendors/lightbox/lightbox.min.css" rel="stylesheet">
  <link href="https://wzdlc1996.github.io/css/main.css" rel="stylesheet">


  
  <link rel="shortcut icon"  href="https://wzdlc1996.github.io/imgs/cat.png" >


  

  

  <style type="text/css">
    @media (min-width: 800px) and (max-width: 850px) {
      .navbar:not(.top-nav-collapse) {
        background: #1C2331 !important;
      }
    }
  </style>


  
  
  <link rel="stylesheet" href="https://wzdlc1996.github.io/css/vendors/highlight/github-gist.css">
  

  
  <link rel="stylesheet" href="https://wzdlc1996.github.io/css/search.css" />

</head>

  <body class="bg-light" data-spy="scroll" data-target="#page-scrollspy" data-offset="90">
  
    
    

    
      


<nav class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">

    
    <a class="navbar-brand" href="https://wzdlc1996.github.io">
      
      <img class="avatar" src="https://wzdlc1996.github.io/imgs/cat.png" style="width: 40px!important;height: auto;" class="d-inline-block align-top" alt="">
      
      <strong> Leonard</strong>
    </a>

    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    
    <div class="collapse navbar-collapse" id="navbarSupportedContent">

      
      <ul class="navbar-nav mr-auto ">
        <li class="nav-item ">
          <a class="nav-link" href="https://wzdlc1996.github.io">Home</a>
        </li>
        
        <li class="nav-item ">
          <a class="nav-link" href="https://wzdlc1996.github.io/artic/">
            Articles
            
          </a>
        </li>

        
        <li class="nav-item ">
          <a class="nav-link" href="https://wzdlc1996.github.io/notes/">
            Notes
            
          </a>
        </li>

        
      </ul>
      
      <a data-toggle="modal" data-target="#modalSearch" style="outline: none;">
        <svg class="aa-input-butn" viewBox="654 -372 1664 1664">
          <path
            d="M1806,332c0-123.3-43.8-228.8-131.5-316.5C1586.8-72.2,1481.3-116,1358-116s-228.8,43.8-316.5,131.5  C953.8,103.2,910,208.7,910,332s43.8,228.8,131.5,316.5C1129.2,736.2,1234.7,780,1358,780s228.8-43.8,316.5-131.5  C1762.2,560.8,1806,455.3,1806,332z M2318,1164c0,34.7-12.7,64.7-38,90s-55.3,38-90,38c-36,0-66-12.7-90-38l-343-342  c-119.3,82.7-252.3,124-399,124c-95.3,0-186.5-18.5-273.5-55.5s-162-87-225-150s-113-138-150-225S654,427.3,654,332  s18.5-186.5,55.5-273.5s87-162,150-225s138-113,225-150S1262.7-372,1358-372s186.5,18.5,273.5,55.5s162,87,225,150s113,138,150,225  S2062,236.7,2062,332c0,146.7-41.3,279.7-124,399l343,343C2305.7,1098.7,2318,1128.7,2318,1164z" />
        </svg>
      </a>

    </div>

  </div>
</nav>





<div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="exampleModalLabel">Search</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <div class="aa-input-container" id="aa-input-container">
    <input type="search" id="aa-search-input" class="aa-input-search" placeholder="Search for titles or URIs..." name="search" autocomplete="off" />
    
    <svg xmlns="http://www.w3.org/2000/svg" class="aa-input-icon" width="120" height="16">
      <g fill="none" fill-rule="evenodd">
        <path fill="#848AB8" fill-rule="nonzero" d="M4.202 10.434c-.497.378-1.18.564-2.057.564-.873 0-1.588-.13-2.145-.39V9.46c.352.159.728.283 1.122.375.398.092.768.137 1.109.137.5 0 .869-.09 1.107-.274a.883.883 0 0 0 .356-.735.901.901 0 0 0-.328-.706c-.219-.193-.67-.421-1.353-.685-.705-.274-1.201-.586-1.49-.94-.29-.35-.435-.774-.435-1.267 0-.62.229-1.106.688-1.462.457-.356 1.073-.534 1.844-.534.74 0 1.476.155 2.21.467l-.401.988c-.687-.276-1.3-.415-1.84-.415-.408 0-.72.085-.93.255a.83.83 0 0 0-.318.678c0 .193.044.36.128.495.085.137.225.267.419.388.193.123.54.283 1.046.482.568.226.984.439 1.248.635.263.196.457.417.58.665.124.245.185.538.185.873 0 .661-.248 1.179-.745 1.554zm2.53-.201c-.512-.509-.768-1.21-.768-2.102 0-.917.236-1.638.712-2.162.477-.525 1.13-.787 1.962-.787.772 0 1.382.225 1.83.675.447.45.67 1.068.67 1.857v.644H7.242c.017.545.17.964.46 1.257.288.293.696.438 1.22.438a4.6 4.6 0 0 0 .965-.094c.298-.062.618-.166.96-.312v.97c-.305.138-.61.237-.921.293a5.77 5.77 0 0 1-1.063.087c-.908.001-1.62-.254-2.132-.764zm.956-3.787c-.238.24-.38.59-.426 1.049h2.653c-.007-.463-.123-.813-.348-1.052-.227-.239-.537-.359-.932-.359-.393 0-.709.12-.947.362zm8.269 3.669h-.043c-.282.342-.565.574-.85.697-.286.125-.653.186-1.1.186-.575 0-1.024-.148-1.345-.446-.322-.297-.483-.718-.483-1.264 0-.578.224-1.015.67-1.309.448-.294 1.131-.455 2.047-.482l1.01-.03v-.301c0-.36-.09-.627-.262-.803-.175-.18-.445-.268-.812-.268-.3 0-.587.042-.861.126-.276.085-.54.184-.794.3l-.401-.853c.317-.16.664-.28 1.041-.363a4.968 4.968 0 0 1 1.068-.124c.743 0 1.304.156 1.683.466.379.312.568.8.568 1.468v3.78h-.888l-.248-.78zm-.515-.393c.272-.242.409-.581.409-1.018v-.488l-.751.03c-.585.022-1.01.114-1.277.282-.266.168-.398.425-.398.77 0 .25.076.443.232.58.155.137.388.206.699.206.451 0 .813-.12 1.086-.362zm6.97-4.49l-.122 1.112c-.177-.04-.36-.06-.551-.06-.495 0-.899.154-1.207.466-.307.312-.462.715-.462 1.213v2.933h-1.24V5.284h.97l.165.989h.063c.194-.335.447-.601.758-.797.313-.196.65-.294 1.008-.294.249 0 .455.017.619.05zm1.423 5.023c-.459-.496-.69-1.207-.69-2.134 0-.945.242-1.67.722-2.177.483-.507 1.176-.761 2.087-.761.616 0 1.17.11 1.663.33l-.374.958c-.526-.195-.959-.293-1.301-.293-1.01 0-1.516.643-1.516 1.933 0 .63.125 1.103.377 1.419.253.316.622.475 1.108.475a3.27 3.27 0 0 0 1.57-.397v1.041c-.22.125-.458.215-.709.269a4.28 4.28 0 0 1-.918.082c-.887-.003-1.559-.25-2.02-.745zm8.916.641v-3.45c0-.435-.09-.756-.271-.97-.183-.213-.47-.321-.865-.321-.521 0-.905.151-1.151.45-.243.3-.366.8-.366 1.503v2.788h-1.242V3h1.242v2.003c0 .321-.02.666-.063 1.03h.079c.169-.27.403-.48.705-.628a2.362 2.362 0 0 1 1.055-.223c1.417 0 2.126.685 2.126 2.055v3.66h-1.249z"/>
        <path fill="#848AB8" d="M42.828 6.115c.418.537.628 1.29.628 2.26 0 .974-.213 1.732-.637 2.275-.425.542-1.012.813-1.768.813-.76 0-1.352-.27-1.773-.81h-.087l-.233.703H38V3h1.278v1.987c0 .147-.007.365-.022.655-.014.29-.025.475-.032.553h.054c.405-.59 1.005-.886 1.795-.886.75 0 1.336.27 1.755.806zm-3.201.674c-.225.3-.343.8-.35 1.5v.087c0 .721.117 1.245.349 1.57.233.323.61.485 1.136.485.454 0 .797-.177 1.031-.532.233-.354.352-.866.352-1.535 0-1.35-.466-2.025-1.403-2.025-.518 0-.887.15-1.115.45zm5.792-1.372l1.223 3.366c.186.48.31.93.37 1.354h.044c.034-.196.094-.435.18-.716.088-.28.548-1.615 1.382-4.003H50l-2.573 6.73C46.96 13.381 46.18 14 45.087 14a3.66 3.66 0 0 1-.826-.092v-.998c.192.043.411.065.658.065.618 0 1.05-.353 1.3-1.058l.223-.56-2.415-5.94h1.392z"/>
        <path fill="#5468FF" fill-rule="nonzero" d="M70.306 0a1.87 1.87 0 0 1 1.865 1.872V12.35a1.87 1.87 0 0 1-1.865 1.872h-10.44A1.87 1.87 0 0 1 58 12.35V1.867C58 .837 58.834 0 59.866 0h10.44zM65.25 3.593a4.012 4.012 0 0 0-4.003 4.02 4.008 4.008 0 0 0 4.003 4.017 4.012 4.012 0 0 0 4.003-4.02 4.006 4.006 0 0 0-4.003-4.017zm0 6.85a2.827 2.827 0 0 1-2.82-2.83 2.827 2.827 0 0 1 2.82-2.829 2.827 2.827 0 0 1 2.82 2.83c0 1.561-1.26 2.83-2.82 2.83zm0-2.972c0 .06.064.103.12.074l1.867-.97c.042-.021.055-.074.033-.116a2.32 2.32 0 0 0-1.933-1.179c-.043 0-.086.035-.086.083l-.001 2.108zm-2.614-3.658l-.246-.245a.61.61 0 0 0-.868 0l-.292.293a.615.615 0 0 0 0 .87l.24.243c.04.04.095.03.13-.008a4.484 4.484 0 0 1 1.023-1.028c.043-.026.047-.087.013-.125zm3.925-1.126a.616.616 0 0 0-.615-.617h-1.432a.617.617 0 0 0-.614.617v.5c0 .056.052.096.107.082a4.5 4.5 0 0 1 2.451-.012.084.084 0 0 0 .104-.081l-.001-.489zm28.457 9.023c0 1.294-.33 2.238-.995 2.838-.664.6-1.68.9-3.047.9-.5 0-1.538-.097-2.368-.28l.305-1.502c.695.146 1.612.185 2.092.185.762 0 1.306-.155 1.63-.465.326-.311.485-.77.485-1.38v-.31a5.712 5.712 0 0 1-.742.28c-.305.092-.66.141-1.057.141-.523 0-1-.082-1.432-.247a2.99 2.99 0 0 1-1.11-.726 3.3 3.3 0 0 1-.718-1.202c-.17-.48-.257-1.336-.257-1.966 0-.59.092-1.33.271-1.824a3.51 3.51 0 0 1 .801-1.274 3.67 3.67 0 0 1 1.275-.824 4.688 4.688 0 0 1 1.723-.324c.616 0 1.183.078 1.736.169.554.093 1.024.19 1.408.296v7.516zm-5.274-3.738c0 .794.174 1.675.524 2.044.35.367.8.551 1.354.551.3 0 .587-.044.854-.124.265-.084.48-.18.65-.297V5.444a7.53 7.53 0 0 0-1.252-.16c-.689-.018-1.213.262-1.582.71-.363.452-.549 1.242-.549 1.978h.001zm14.278 0c0 .64-.092 1.123-.281 1.651a3.897 3.897 0 0 1-.8 1.351 3.534 3.534 0 0 1-1.242.867c-.485.203-1.233.32-1.605.32-.374-.006-1.116-.113-1.596-.32a3.626 3.626 0 0 1-1.238-.868 3.993 3.993 0 0 1-.806-1.35 4.477 4.477 0 0 1-.29-1.652c0-.64.086-1.254.281-1.778.195-.523.465-.969.815-1.342a3.646 3.646 0 0 1 1.242-.86 3.993 3.993 0 0 1 1.582-.301c.573 0 1.102.101 1.587.3.485.203.903.49 1.242.862.345.374.61.818.806 1.343.204.521.304 1.137.304 1.776h-.001zm-1.94.004c0-.818-.18-1.5-.53-1.973-.349-.48-.838-.719-1.465-.719-.625 0-1.116.238-1.465.718-.349.478-.519 1.155-.519 1.973 0 .83.175 1.387.523 1.867.35.483.841.72 1.467.72.625 0 1.116-.242 1.465-.72.349-.486.522-1.038.522-1.867l.002.001zm6.165 4.187c-3.11.013-3.11-2.51-3.11-2.912L105.134.3l1.896-.3v8.89c0 .23 0 1.672 1.218 1.677v1.596zm3.343 0h-1.906V3.984l1.907-.3v8.479zm-.956-9.372c.637 0 1.155-.514 1.155-1.148 0-.634-.513-1.147-1.155-1.147-.64 0-1.154.513-1.154 1.147s.52 1.148 1.155 1.148h-.001zm5.696.9c.626 0 1.155.078 1.582.232.428.156.77.373 1.024.649.253.277.432.655.539 1.052.111.396.165.833.165 1.312v4.871c-.29.064-.732.137-1.324.224-.591.087-1.256.13-1.993.13-.49 0-.942-.049-1.344-.141a2.833 2.833 0 0 1-1.043-.45 2.174 2.174 0 0 1-.675-.804c-.16-.329-.243-.794-.243-1.28 0-.464.092-.759.27-1.079.187-.32.433-.58.745-.784a3.163 3.163 0 0 1 1.085-.435 6.131 6.131 0 0 1 2.688.038v-.311c0-.217-.024-.425-.078-.619a1.335 1.335 0 0 0-.27-.517 1.263 1.263 0 0 0-.515-.349 2.25 2.25 0 0 0-.81-.146 7.05 7.05 0 0 0-1.2.116 5.662 5.662 0 0 0-.892.219l-.229-1.556a7.85 7.85 0 0 1 1.048-.245 8.239 8.239 0 0 1 1.47-.126zm.16 6.872c.583 0 1.014-.033 1.315-.092V8.544a3.627 3.627 0 0 0-.456-.093 4.605 4.605 0 0 0-.66-.048 4.07 4.07 0 0 0-.635.049 1.962 1.962 0 0 0-.577.168c-.169.084-.31.2-.412.35-.106.15-.155.237-.155.465 0 .447.155.702.436.873.287.174.665.257 1.146.257l-.002-.002zM79.029 3.74c.626 0 1.155.078 1.582.232.426.155.77.374 1.023.65.257.28.432.653.539 1.05.112.397.165.833.165 1.313v4.871c-.293.062-.733.136-1.324.222-.594.09-1.258.132-1.996.132-.49 0-.94-.048-1.344-.14a2.833 2.833 0 0 1-1.043-.45 2.183 2.183 0 0 1-.673-.806c-.161-.329-.244-.794-.244-1.278 0-.465.092-.76.272-1.08a2.3 2.3 0 0 1 .742-.784 3.165 3.165 0 0 1 1.087-.436 6.222 6.222 0 0 1 1.95-.091 5.9 5.9 0 0 1 .737.131v-.31c0-.218-.023-.427-.077-.62a1.324 1.324 0 0 0-.272-.518 1.28 1.28 0 0 0-.515-.349 2.25 2.25 0 0 0-.81-.145c-.436 0-.834.054-1.198.116a5.345 5.345 0 0 0-.892.218l-.228-1.555a7.667 7.667 0 0 1 1.048-.246 7.821 7.821 0 0 1 1.469-.127h.002zm.164 6.877c.583 0 1.015-.033 1.316-.092V8.597a3.683 3.683 0 0 0-.457-.093 4.615 4.615 0 0 0-.66-.048c-.21 0-.423.015-.638.049a1.92 1.92 0 0 0-.576.169c-.17.083-.31.199-.412.35-.107.15-.155.236-.155.464 0 .447.154.702.435.873.281.169.665.258 1.145.258l.002-.002zm7.69 1.547c-3.109.013-3.109-2.51-3.109-2.912L83.767.3l1.896-.3v8.89c0 .23 0 1.672 1.218 1.677v1.594l.002.003z"/>
      </g>
    </svg>
</div>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/algoliasearch.min.js"></script>
<script src="https://res.cloudinary.com/jimmysong/raw/upload/rootsongjc-hugo/autocomplete.min.js"></script>
<script>
var client = algoliasearch("CKGQ2NF14W", "47466714a15e4af509908b3be9a18065");
var index = client.initIndex('leonard-blog');
autocomplete('#aa-search-input',
{ hint: false}, {
    source: autocomplete.sources.hits(index, {hitsPerPage: 8}),
    displayKey: 'name',
    templates: {
        suggestion: function(suggestion) {
            console.log(suggestion);
            return '<span>' + '<a href="https://wzdlc1996.github.io/' + suggestion.uri.toLowerCase() + '/">' +
            suggestion._highlightResult.title.value + '</a></span>';
        }
    }
});
</script>

        </div>
      </div>
    </div>
  </div>
 
      







<div id="site-header" class="carousel slide carousel-fade" data-ride="carousel" style="height: 18rem;" >  

  
  
  

  
  <div class="carousel-inner" role="listbox">
    
      

        
        <div class="carousel-item active">
          <div class="view" style="background-image: url('https://wzdlc1996.github.io/imgs/header-slides/56562834_p0.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">

              
              
              

            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://wzdlc1996.github.io/imgs/header-slides//60104382_p0.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">



            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://wzdlc1996.github.io/imgs/header-slides//63590923_p0.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">



            </div>
            

          </div>
        </div>
        
      
    
      

        
        <div class="carousel-item">
          <div class="view" style="background-image: url('https://wzdlc1996.github.io/imgs/header-slides//66977044_p0.jpg'); background-repeat: no-repeat; background-size: cover;">

            
            <div class="mask rgba-black-light d-flex justify-content-center align-items-center">



            </div>
            

          </div>
        </div>
        
      
    


  </div>
  

  
  <div class="carousel-content text-center white-text wow fadeIn">
    <div class="row mx-0 headfont mt-3 pt-4">
      
      <div class="col-12 col-sm-5 align-middle">
        <a href="https://wzdlc1996.github.io">
          
            <img class="pull-right avatar avatar-md" src="https://wzdlc1996.github.io/imgs/white_cat.png" alt="" >
          
        </a>
      </div>

      <div class="col-12 col-sm-7 text-left pl-2">
        <a href="https://wzdlc1996.github.io">
          <h1 class="mb-2 h1" style="font-weight: 300;" >
            <strong>Leonard</strong>
          </h1>
        </a>


        
        <div class="mt-2" style="font-size: 1rem; color: white;">
            
              <a href="http://github.com/wzdlc1996" target="_blank" rel="noopener"><i class="fab fa-github pr-1" aria-hidden="true"></i></a>
            
            

            

            

            

            

            


            
                <a href="mailto:wzdlc1996@gmail.com"><i class="far fa-envelope-open pr-1" aria-hidden="true"></i></a>
            

            
            
        </div>
      </div>
    </div>
  </div>
  

  
  
  

</div>

  
    

    
  
  <main class="post-main-wrapper">
    
    
    <div class="row">

      

      
      <div class="col-md-10">
      

        
        <div class="z-depth-1  post-wrapper white-bg single-post">

          <div class="post-header text-center" >
  <ul class="post-meta li-x">
    
      
        <li><a href="https://wzdlc1996.github.io/categories/reviews"><i class="fas fa-folder-open pr-1" aria-hidden="true"></i> Reviews </a></li>
      
    
    
  </ul>

  <div class="px-4 post-heading">Quantum Machine Learning: Quantum Algorithms to Classical Data</div>

  <ul class="post-meta li-x mt-1">
    
      <li>Dec 19, 2020</li>
    

    
      <li class="middot"></li>
      <li>29 minutes read</li>
    
  </ul>
  

</div>


          <div class="post-content markdown">
          
          
            





    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    











    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
        
        
    
<h1 id="data-science-and-machine-learning">Data Science and Machine Learning</h1>
<p>Formally, <strong>Data science</strong> is an <strong>inter-disciplinary</strong> field that uses scientific methods, processes, algorithms and systems to extract <strong>knowledge</strong> and insights from many structural and unstructured data<a href="https://en.wikipedia.org/wiki/Data_science">Wikipedia/Data_science</a>. The core object of research in this field is data for the goal of knowledge. This approach is different from research of theoretical study like geometry by deductive reasoning. A nice example is <a href="https://www.sciencedirect.com/topics/engineering/keplers-law">Kepler&rsquo;s Law</a>, here we list two approaches to it in the following to show the difference between two paradigm.</p>
<ol>
<li><strong>Kepler type</strong>
<ul>
<li>Analyze the data from Tycho</li>
<li>Summarize the pattern of data in simple way(the first and second law, Occam&rsquo;s razor)</li>
<li>Fit the data and generalize the quantitative rule(the third law)</li>
</ul>
</li>
<li><strong>Newton type</strong>(also used in the modern textbook)
<ul>
<li>Admit some axioms of the system(Newton&rsquo;s law)</li>
<li>With mathematical approach write the equation and solve it</li>
<li>Discuss the properties of the solution</li>
</ul>
</li>
</ol>
<p>We call the Kepler type <strong>data-driven</strong>, and this paradigm is the core of data science.</p>
<p>Roughly speaking, there are three parts for data science: data collection, data storage, and learn from data. Though the other two are also important, our main goal here is the last one. The algorithm for this purpose is <strong>Machine Learning</strong>. Most machine learning tasks can be classified into the following three frameworks.</p>
<ol>
<li>
<p><strong>Supervised learning</strong></p>
<ul>
<li>Data: a set of input        $x$ )  ,   and its label      $y$ ))   ${x_i, y_i}_{i=1}^N$</li>
<li>Goal: find a model for the map from        $x$ )  ,   to      $y$ ))   of   $y = f(x;\theta)$ 
</li>
</ul>
<p>There are two main applications to supervised learning: regression (continuous      $y$ ))  ) and classification (discretized      $y$ ))  )</p>
</li>
<li>
<p><strong>Unsupervised learning</strong></p>
<ul>
<li>Data: a set of input        $x$ )  ,  , without labels.   $\{x_i\}_{i=1}^N$ 
</li>
<li>Goal: find the hidden patterns or grouping data.</li>
</ul>
<p>Dimensionality reduction, clustering, generative modeling.</p>
</li>
<li>
<p><strong>Reinforcement learning</strong></p>
<ul>
<li>Data: delayed feedback signal(reward) after action. Like the win/lose in a chess game</li>
<li>Goal: learning an optimal policy(i.e. how to act). Like learn how to play a chess game</li>
</ul>
</li>
</ol>
<p>Though we list these classes of machine learning, the modern development are not distinct in this level. To solve the complex problems in the real-world we need the cooperation of different technologies for their own parts. To classify such the mixed projects are difficult and meaningless. As a popular and growing technology, there will be many new contents enter the field of machine learning. Just open your mind and be prepared.</p>
<h1 id="quantum-tech-to-data-science">Quantum Tech to Data Science</h1>
<p>Quantum technology has been one of the most important concepts in the world now. Some people call the control and application of the quantum systems <a href="https://www.nist.gov/topics/physics/introduction-new-quantum-revolution/second-quantum-revolution">the Second Quantum Revolution</a>, to distinguish against the establishment of quantum mechanics in the early 20th century. To data science, the impact of quantum tech is well described by the following figure from <a href="https://en.wikipedia.org/wiki/Quantum_machine_learning">wiki/Quantum-machine-learning</a>.</p>

<div class="flex-center w-100 mainTextImg" style="text-align: center"><img name="preview" src="./Figs/img01.png"/></div>

<p>As quantum tech comes into our sight, a new type of data now is needed to be considering. Classical data is encoded by classical physical systems and its values are deterministic at each stage of processing. The information we touch in the daily life are all classical data, like this report, logical variables by whether voltage in the wire of computer is greater than a threshold or not, and much other analog data. Quantum data is encoded by quantum systems. Like the entities in the Hilbert space(the state of qubit), such data is quiet different from the classical one especially in the read/write rule. By the high representability of digits, we can still simulate the quantum data on classical computer. But since the dimension of Hilbert space (amounts of quantum variables) are exponential to the number of classical variables, this approach is incapably expensive.</p>
<p>Another aspect of the figure above is the type of algorithm. It is not only means the software we handle the data, but also the hardware we used to implement the program. This part contains the storage and processing. The former is qubits and quantum gates, which has been proved to be universal to simulate any quantum system and their evolution, just like the classical bits and classical gates. However, the quantum nature of qubits makes it possible to handle quantum data with polynomial scaling cost(if we can prepare and hold the qubits as easy as we do for classical bits in the sense of scaling). The latter concept (processing), i.e. algorithm or software, is the analog of the classical algorithm and programs running on the classical computer. There are two paradigms for quantum algorithm, one can be represented as the combination of a set of quantum gates,  while the other way is based on the adiabatic theorem (<a href="https://en.wikipedia.org/wiki/Adiabatic_quantum_computation">wiki/Adiabatic-quantum-computation</a>). These two approaches has been proved to be equivalent (<a href="https://arxiv.org/abs/quant-ph/0405098">D.Aharonov 2005</a>, <a href="https://arxiv.org/abs/1706.07646">H.Yu 2018</a>).</p>
<h1 id="quantum-speedup-for-classical-machine-learning">Quantum Speedup for Classical Machine Learning</h1>
<p>Quantum computing has been proven significantly more powerful than classical machine on certain problems. In the past decades, the theory about hardware (architecture) of quantum processor and software (algorithm) on quantum computer have been rapidly developed. Though currently, there are still experimental issues as barriers between us and large scale quantum computer, the theoretical preparation for applying quantum technology on machine learning has been sort of made. In this section, we focus on the quantum speedup for classical machine learning, i.e., the outperformance of quantum algorithm in the field of classical machine learning.</p>
<h2 id="essential-techs-for-applied-quantum-computing">Essential Techs for Applied Quantum Computing</h2>
<p>There are two essential technologies required in quantum machine learning. One is the <strong>quantum Random Accessible Memory</strong>, which is usually mentioned as the hardware, and the other is the <strong>quantum linear algebra algorithms</strong> in software level. The former might be suspected to be essential, since there are actually many quantum machine learning algorithms being free from qRAM. Recently, some new approaches have been studied for handling classical data in a quantum machine like quantum embedding (<a href="https://arxiv.org/abs/2001.03622">S. Lloyd 2020</a>) and quantum feature map (<a href="https://arxiv.org/abs/1804.11326">V. Havlicek 2018</a>). However, as a generic data loader for quantum machine learning on classical data, it is still valuable to discuss it mathematically here.</p>
<h3 id="data-loader-qram">Data Loader: qRAM</h3>
<p>The <strong>Random-Access Memory(RAM)</strong> on classical computers provides essentially a tree structure for addressing. Such addressing with conventionally implementation would cost exponentially large energy.</p>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Conventional Classical RAM architecture
    </summary>
<p>Basically, a classical RAM is composed of a memory array of size     $N$      serving     $N$     bits to read and write, an input register(addressing register) and an output register. A normal memory call can be described as (<a href="https://ecedmans.files.wordpress.com/2014/03/microelectronic-circuit-design-4th-edition-jaeger.pdf">R. C. Jaeger, &ldquo;Microelectronic Circuit Design&rdquo;</a>)</p>
<ol>
<li>An        $n$  -  ---bit string is read into input register. These   $n\sim\log N$   bits store the address of the memory cell to be called, as the path along the tree. For bifurcation case, it is a series of   $\{0,1\}$   with   $n=\log_2 N$ ,, and at       $k$ ,-----th level of the tree, the   $0, 1$   value at       $k$ ,-----th bit denotes the left and right edge.</li>
<li>Along the addressing path, the output register stores the content of memory cell, or a write circuit would modify its value for the write operation.</li>
</ol>
<p>Within this procedure, the first addressing bit should control one gate at that node. However, the       $k$ ,-----th bit must control all   $2^{k-1}$   gates at the       $k$ ,-----th level of the tree for all possible paths. Like:</p>
<div class="flex-center w-100 mainTextImg" style="text-align: center">
<img name="preview" src="./Figs/img_cram.png"/>
</div>
<p>from the paper (<a href="https://journals.aps.org/pra/pdf/10.1103/PhysRevA.78.052310">V. Giovannetti 2008</a>).</p>
<p>Thus, though classical RAM serves the   $\mathcal{O}(1)$   time complexity (or   $\mathcal{O}(\log N)$   for generic random addressing) for a memory call, it actually <strong>activates</strong>   $\mathcal{O}(2^n)$   gates to implement it.</p>
<p>However, as they said in the introduction of the paper (<a href="https://journals.aps.org/pra/pdf/10.1103/PhysRevA.78.052310">V. Giovannetti 2008</a>):</p>
<blockquote>
<p>A classical RAM that uses the bucket-brigade (ps. introduced in this paper.) addressing schemes need only activate   $\mathcal{O}(n= \log N)$   transistors in the course of a memory call, in contrast with a conventional RAM that activates   $\mathcal{O}(2^n = N)$   transistors. As a result, a RAM that uses our design might operate with less dissipation and power consumption than a conventional RAM. <strong>Note, however, that energy costs in the memory addressing are not sufficiently high in current RAM chips to justify an immediate adoption of the bucket brigade. Other source of inefficiencies and dissipations are currently predominant (mostly in the memory cells themselves).</strong> However, new promising memory cell technologies are being developed (e.g., the &ldquo;memristor&rdquo; cells), which would drastically cut back cell dissipation, so that cutting back dissipation in the addressing may become important in the future.</p>
</blockquote>
<p>Their architecture can also offer advantages for classical RAM, but it cannot resolve the dominant problem of classical RAM. According to this (<a href="https://quantumcomputing.stackexchange.com/questions/2298/are-bucket-brigate-qram-architectures-also-advantageous-in-the-classical-case">stackexchange answer</a>):</p>
<blockquote>
<p>I think that it would indeed work in classical RAM, but the hardware constraints didn&rsquo;t supply the &rsquo;evolutionary pressure&rsquo; required for it to be develiped and implemented.</p>
</blockquote>
<p>currently bucket-brigade architecture is still focused on resolving the quantum issue, like resource efficiency and fault tolerance. (<a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.102.032608">A. Paler 2020</a>)</p>
</details>
<p>The <strong>bucket-brigade</strong> architecture is proposed to resolve the issue that in conventional one, there are always few addressing bits related to exponentially many transistors to control the path. Like the bits controlling the last level of the tree, which needs to control   $2^{n-1}$   transistors. This property makes it hard to work in a quantal way, in which decoherence led by many body interaction should be forbidden.</p>
<p><strong>Bucket-Brigade</strong> architecture modifies every nodes in the bifurcation tree into a (qu)trit, which could have three possible states.</p>

<div class="flex-center w-100 mainTextImg" style="text-align: center">
<img name="preview" src="https://raw.githubusercontent.com/qsharp-community/qram/master/docs/images/bb.gif"/>

</div>

<p>(The figure is cited from <a href="https://github.com/qsharp-community/qram">github.com/qsharp-community/qram</a>)The   $\ket{0},\ket{1}$   state of qutrits shares the same operation of original switches: they indicate which next step to choose at this node (referred as   $\ket{\textrm{left}}, \ket{\textrm{right}}$ )). While the other state, denoting as     $\ket{\textrm{wait}}$   ,, means a waiting node. When a   $0,1$ --valued bit encounters it, it &ldquo;absorb&rdquo; the information and switch itself into the same value, including the case that incoming bit is at a superposition state. In a memory call, the bits in input register is popped sequentially into a initialized tree (with all nodes at     $\ket{\textrm{wait}}$   , state). When the bit encounters a    $\ket{0}, \ket{1}$    node it propagates into the next level. Thus, when the input register becomes empty, a path towards memory cells is constructed. When input register is in a superposition state, it is further a superposition state among many paths with the same amplitude. After the bus qubit has loaded the data, the nodes along addressing path would be recovered to     $\ket{\textrm{wait}}$   , for further usage.</p>
<p>This architecture allows a memory call with   $\mathcal{O}(n)$   gates activated, and <strong>the superposition addressing is potentially supported.</strong> Now we show how to use qRAM implement the state-preparation, or classical data loader for quantum computing. Mathematically, we want to achieve the map (<a href="https://royalsocietypublishing.org/doi/10.1098/rspa.2017.0551">C. Ciliberto 2017</a>, <a href="https://www2.eecs.berkeley.edu/Pubs/TechRpts/2014/EECS-2014-211.pdf">A. Prakash 2014</a>)</p>
<p>$$
\{x_i\}_ {i=1}^N \mapsto \ket{x} = \frac 1 {\mathcal{A}}\sum_{i,d} x_i^d \ket{i, d}.
$$</p>
<p>where   $\mathcal{A}^{-1}$   is the normalization factor. This map encoded classical dataset onto the amplitudes instead of basis.</p>
<p>We begin with the vector   $\{x_i\}_{i=0}^{N-1}$ ,, with qRAM we can prepare the state (with uniform superposition addressing) with ancilla qubits (with the size of   $\log N$ ))</p>
<p>$$
\ket{\psi} \otimes \ket{0} = \frac 1 {\sqrt{N}}\sum_{i=0}^{N-1} \ket{i}\ket{x_i} \otimes \ket{0}
$$</p>
<p>Now we apply a rotation conditioned by the content in memory cells</p>
<p>$$
\begin{aligned}
\ket{\tilde{x}} &=\exp\Big(-\ti t \sum_{i=0}^{N-1} (-x_i)\ket{i,x_i}\bra{i,x_i} \otimes \sigma_x\Big) \ket{\psi}\otimes \ket{0} \\
&= \frac 1 {\sqrt{N}}\sum_{i=0}^{N-1} \ket{i}\ket{x_i} \Big(\ket{0} + \ti t x_i \ket{1} + \mathcal{O}(t^2)\Big)
\end{aligned}
$$</p>
<p>Thus, with proper post-selection, we can prepare the state of   $\sum_{i=0}^{N-1} x_i\ket{i}$ .. Similar procedure can also applied for general datasets.</p>
<p>Though this fast amplitude encoding is very exciting, however, unfortunately, there is still no one has actually done this. As for do we need a qRAM, the following comment from <a href="https://github.com/qsharp-community/qram">github.com/qsharp-community/qram</a> gives a nice answer</p>
<blockquote>
<p><strong>Sometimes.</strong> You&rsquo;ll need a qRAM, or some more general means of <em>quantum state preparation</em> in quantum machine learning (QML) algorithms that require you to load in classical data, or query an oracle that returns classical data. I&rsquo;ve heard a number of stories of people working on QML being actively discouraged from doing so because &ldquo;QML won&rsquo;t work without a qRAM&rdquo;. That&rsquo;s just not true, because <em>many QML algorithms do not need a qRAM.</em> Now, whether or not they yield any quantum advantage is a separate question, and won&rsquo;t be discussed here. The key point is that <em>some</em> QML algorithms need a qRAM, and they will potentially run into trouble as per the next question.</p>
</blockquote>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        the next question mentioned
    </summary>
<blockquote>
<p><strong>Can we design an efficient qRAM?</strong></p>
<p><strong>Maybe</strong>. In the primer we&rsquo;ll take a look at proposals that will in principle run in polynomial depth, and others that scale far worse. There are some very interesting qubit-time tradeoffs one can explore, in particular if the data being stored has some sort of underlying structure. Regardless, even if we can design an efficient circuit, we&rsquo;d also like something that is efficient in a fault-tolerant setting, and this is potentially very expensive.</p>
</blockquote>
</details>
<p>Another discussion can be found at the paper (<a href="https://royalsocietypublishing.org/doi/10.1098/rspa.2017.0551">C. Ciliberto 2017</a>), in which the author list three issues for the current qRAM research:</p>
<ol>
<li>Do all components of the qRAM require to be error-corrected. If the answer is yes, such exponential physical resources would not be built in an experimental setting.</li>
<li>The comparison is thought as unfair (<a href="http://pirsa.org/displayFlash.php?id=16080019">D. Steiger&rsquo;s talk in 2016</a>). The argument states that the benchmark should be done with the same hardware resources scaling, which might decrease the quantum-speedup. The qRAM-based algorithms should be carefully considered.</li>
<li>As pointed out in (<a href="https://www.nature.com/articles/nphys3272">S. Aaronson 2015</a>), the fast state preparation based on qRAM requires the classical data distributed relatively uniform. However, in this case, classical random algorithm can be quite fast and reliable, which also makes the exponential-speedup disappeared.</li>
</ol>
<h3 id="quantum-linear-algebra">Quantum Linear Algebra</h3>
<p>Though the idea about using quantum resources to enhance the learning algorithms had attracted much attention since 1990s, the rapid growth of quantum machine learning actually began in 2009, by the help of quantum algorithm for linear system. In this section we discuss the algorithm, named as HHL algorithm, after its inventor Harrow, Hassidim, and Lloyd. (<a href="https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.103.150502">HHL 2009</a>).</p>
<p>HHL algorithm try to solve the linear system reads</p>
<p>$$
\bm{A} \bm{x} = \bm{b} \Leftrightarrow \begin{bmatrix} \bm{0} & \bm{A} \\ \bm{A}^\dagger & \bm{0} \end{bmatrix} \begin{bmatrix}
\bm{0}\\ \bm{x} 
\end{bmatrix} = \begin{bmatrix} \bm{b} \\ \bm{0}\end{bmatrix}
$$</p>
<p>by the map, we can just consider the case of coefficients matrix to be <strong>Hermitian.</strong> The pseudo-code for HHL algorithm reads</p>
<ul>
<li><strong>Input</strong>:   $\ket{b} = \sum_{i=0}^{N-1} b_i \ket{i}$ ,, unitary matrix   $\hat U(t) = \exp(\ti t\sum_{i,j=0}^{N-1} A_{ij}\ket{i}\bra{j})\equiv \exp(\ti \hat A t)$ 
</li>
<li><strong>Output</strong>: The amplitude-encoded solution   $\ket{x} = \sum_{i=0}^{N-1} x_i \ket{i}$ ,, in which   $\|\bm{A} \bm{x} - \bm{b}\| \lt \epsilon$ 
</li>
<li><strong>Notation</strong>:</li>
<li><strong>Start</strong>:
<ol>
<li>
<p>Prepare initial state   $\ket{\psi_0}=\ket{0}_a\ket{0}_c\ket{b}$   with the subscript   $a, c$   denoting ancilla and controlled</p>
</li>
<li>
<p>Apply   $\log T$   Hadamard gates to make a uniform superposition control register</p>
<p>$$
       \ket{\psi_0} \rightarrow \ket{\psi_1}=\ket{0}_ a\otimes \frac 1 {\sqrt{T}} \sum_{\tau = 0}^{T-1} \ket{\tau}_c \otimes \ket{b}
       $$</p>
</li>
<li>
<p>Apply a <code>controlled evolution</code> of   $\hat U_c = \sum_{\tau=0}^{T-1} \hat I_a\otimes (\ket{\tau}\bra{\tau})_c \otimes \hat U(\tau z/T)$ ..</p>
<p>$$
       \ket{\psi_1}\rightarrow \ket{\psi_2}= \hat U_c \ket{\psi_1} = \frac 1 {\sqrt{T}}\sum_{\tau=0}^{T-1} \ket{0}_a \ket{\tau}_c \sum _{j=0}^{N-1} e^{\ti \lambda_j \tau z/T} \ket{\lambda_j}\braket{\lambda_j|b}
       $$
in which we assume   $\hat A\ket{\lambda_j} = \lambda_j\ket{\lambda_j}$ 
</p>
</li>
<li>
<p>Apply the <code>Fourier transform</code> on the control register</p>
<p>$$
       \ket{\psi_2}\rightarrow \ket{\psi_3}= \sum_{j=0}^{N-1} \sum_{\omega=0}^{T-1} \alpha_{\omega|j} \braket{\lambda_j|b} \ket{0}_a\ket{\omega}_c\ket{\lambda_j}
       $$</p>
<p>Note the amplitude   $|\alpha_{\omega|j}|$   is significant only when   $\lambda_j \approx 2\pi \omega /z = \tilde{\lambda}_\omega$ 
</p>
</li>
<li>
<p>Apply a <code>controlled rotation</code> on ancilla qubit, controlled by   $\omega$ ..</p>
<p>$$
       \ket{\psi_3}\rightarrow \ket{\psi_4} = \sum_{j=0}^{N-1}\sum_{\omega=0}^{T-1} \alpha_{\omega|j}\braket{\lambda_j|b} \Big(\sqrt{1-\frac {C^2} {\tilde{\lambda}_\omega^2}}\ket{0}+\frac {C} {\tilde{\lambda}_{\omega}} \ket{1}\Big)_a \ket{\omega}_c\ket{\lambda_j}
       $$</p>
</li>
<li>
<p>Initialize the control register and make post-selection that ancilla qubit should be   $1$ .. Then the output register</p>
<p>$$
       \ket{x} \approx \sum_{j=0}^{N-1} \frac 1 {\lambda_j} \braket{\lambda_j|b} \ket{\lambda_j} = \ket{\bm{A}^{-1}\bm{b}}
       $$</p>
</li>
</ol>
</li>
<li><strong>End</strong></li>
</ul>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Phase Estimation
    </summary>
<p>The <code>Phase Estimation</code> algorithm tries to find an eigenvalue of given unitary operator  - $\hat U$    with the eigenvector   $\ket{\psi}$   given. i.e., to find the value of   $\theta\in [0,1)$   in the equation(<a href="https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm">Wikipedia/Quantum_phase_estimation_algorithm</a>)</p>
<p>$$
\hat U\ket{\psi} = e^{2\pi \ti \theta}\ket{\psi}
$$</p>
<p>The operation can be implemented by the following circuit. Given        $n$  -  ---qubit register initialized by        $n$  -  -- Hadamard gates as</p>
<p>$$
\ket{\textrm{ini}} = \Big(\frac 1 {\sqrt{2}} (\ket{0}+\ket{1})\Big)^{\otimes n} \otimes \ket{\psi}
$$</p>
<p>Then with        $n$  -  -- controlled-- $U$   gates operating as</p>
<p>$$
\begin{aligned}
\ket{\textrm{ini}} &\rightarrow \bigotimes_{j=1}^n(\ket{0}\bra{0} \otimes \hat I+\ket{1}\bra{1} \hat U^{2^{n-j}})_{\textrm{on j-th}} \ket{\textrm{ini}} \\
&= \bigotimes_{j=1}^n \frac 1 {\sqrt{2}}\big(\ket{0} + e^{\ti 2\pi \theta\times 2^{n-j}}\ket{1}\big) \otimes \ket{\psi} \\
&= \frac 1 {2^{n/2}}\sum_{b_1 b_2\cdots b_n} \Big(\ket{b_1b_2\cdots b_{n}} \exp\big(\ti 2\pi \theta\times \sum_{l=1}^{n} b_l 2^{n-l}\big)\Big)\otimes \ket{\psi} \\
&= \frac 1 {2^{n/2}} \sum_{k=0}^{2^n-1} e^{\ti 2\pi k \theta }\ket{k} \ket{\psi}
\end{aligned}
$$</p>
<p>Then with quantum Fourier transformation on the        $n$  -  ---qubit register to find the period of function   $e^{\ti 2\pi \theta k}$   versus       $k$ ,----, one gets the value of   $\theta$ .. For error limit   $\epsilon$ ,, phase estimation needs   $\mathcal{O}(\log 1/\epsilon)$   qubits and   $\mathcal{O}(1/\epsilon)$   controlled- - $\hat U$    gates.</p>
<p>Thus, the core of HHL algorithm is to make a parallel version of phase estimation for    $e^{\ti \hat A t}$ .,, and by controlled rotation together with post-selection to prepare the inverse operator   $\sum_{j} \ket{\lambda_j} (\lambda_j)^{-1} \bra{\lambda_j}$ ..</p>
</details>
<p>The key of HHL algorithm is the quality of phase estimation subroutine. <strong>Ignoring the cost of preparation of   $\ket{b}$ *</strong>, the bottleneck of runtime is simulate the evolution of    $e^{\ti \hat A t}$ .,. In their original paper, they suggest the algorithm in (<a href="https://link.springer.com/article/10.1007/s00220-006-0150-x">D. Berry 2006</a>) for sparse matrix and HHL algorithm reaches   $\mathcal{O}(\log N (\log^* N)^2)$   (<a href="https://journals.aps.org/prl/supplemental/10.1103/PhysRevLett.103.150502">SuppInfo for HHL</a>).   $\log^* N$   (read &ldquo;log star&rdquo;) is a slow growth function (<a href="https://en.wikipedia.org/wiki/Iterated_logarithm">Wikipedia/Iterated_logarithm</a>), so usually we thought HHL algorithms has a exponential speedup in this context.</p>
<p>HHL algorithm does have some caveats which make it not an efficient quantum algorithm for linear solver. As discussed in (<a href="https://www.nature.com/articles/nphys3272">S. Aaronson 2015</a>), there are at least four critical issues in HHL algorithm</p>
<ol>
<li>The preparation of   $\ket{b} = \sum b_j \ket{i}$ ..</li>
<li>The simulation for general    $\bm{A}$ 
  driving quantum evolution. (in (<a href="https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.120.050502">L. Wossnig 2018</a>), an algorithm for dense matrix with complexity of   $\tilde{\mathcal{O}}(\sqrt{n})$ .. For soft-O notation see <a href="https://en.wikipedia.org/w/index.php?title=Big_O_notation&amp;section=22#Extensions_to_the_Bachmann.E2.80.93Landau_notations">Wikipedia/Big_O_notation</a>)</li>
<li>The robustness of inverse the matrix    $\bm{A}$ 
 </li>
<li>How to extract information encoded in    $\ket{x}$  .. (For the application of compute   $\bm{x}^T \bm{M} \bm{x}$ ,, the classical computer can make an estimate within   $\mathcal{O}(N)$   time.)</li>
</ol>
<p>Though with these caveats, HHL algorithm works well as an approximately method for preparation of the solution of   $\bm{A}\bm{x} = \bm{b}$   in an amplitude encoded manner. It can be good enough for some  applications (for optimization subroutine) like finite element method (<a href="https://arxiv.org/pdf/1512.05903.pdf">A. Montanaro 2016</a>) and linear fitting (<a href="https://ui.adsabs.harvard.edu/abs/2012PhRvL.109e0505W">N. Wiebe</a>)</p>
<h2 id="quantum-machine-learning-algorithms">Quantum Machine Learning Algorithms</h2>
<h3 id="quantum-svm">Quantum SVM</h3>
<p><strong>Support Vector Machine(SVM)</strong> is one of the most important classical learning algorithm mainly for data classification. One of its advantages is that we understand how it works better than most black-box algorithms.</p>
<p>The training set has     $N$     data points as   $D=\{(x_j; y_j): x_j\in \mathbb{R}^d, y_j =\pm 1\}$ .. SVM tries to find a maximum-margin hyperplane with normal vector   $w\in \mathbb{R}^d$   that divides these points into two classes. Formally, the point        $x$ )  ,   should be separated by the value of   $w\cdot x + b$ .. If   $w\cdot x + b \geq 1$ ,, then this point is of class   $y = 1$ .. While   $w\cdot x + b \leq -1$   it should be of   $y=-1$ .. Samples on the margin (i.e.   $w\cdot x+b=\pm 1$   are usually called <strong>support vectors</strong>) The SVM training is to find parameters    $w, b$    such that</p>
<p>$$
\forall (x_j; y_j) \in D : y_j(w\cdot x_j + b) \geq 1 .
$$</p>
<p>and makes the distance between these two classes distant largely enough, i.e., maximize   $2/\|w\|$ .. Thus, the optimization form of SVM training reads</p>
<p>$$
\min_{w, b} \frac 1 2 \|w\|^2 \ \textrm{ s.t. } y_i(w\cdot x_i+b)\geq 1, i=1,\cdots,N 
$$</p>

<div class="flex-center w-100 mainTextImg" style="text-align: center"><img name="preview" src="./Figs/img_svm.png"/></div>

<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Note: Solution of SVM and time complexity
    </summary>
<p>With   $y_i(w\cdot x_i+b) \geq 1$   being linear constraint for   $w$   and   $b$ ,, the training of SVM is actually a convex optimization problem. The Slater&rsquo;s condition for convex optimization problem reads (<a href="https://web.stanford.edu/~boyd/cvxbook/bv_cvxbook.pdf">Stephen Boyd&rsquo;s textbook</a>)</p>
<blockquote>
<p>Given convex optimization problem:
$$
\begin{aligned}
\textrm{minimize}\indent & f(x)\\
\textrm{subject to }\indent & u_i(x) \leq 0 \ , \ i=1,\cdots,m \\
&v_i(x) = 0 \ , \ i=1,\cdots, p
\end{aligned}
$$
in which   $f, u_i$   are <strong>convex function</strong>, equality constraint functions   $v_i(x) = a_i\cdot x + b_i$   are <strong>affine</strong>.
<strong>Slater&rsquo;s condition</strong> holds iff there exists an        $x$ )  ,   such that:
$$
u_i(x) \lt 0 \ , \ i=1,\cdots,m \ ; \ v_i(x) = 0 \ , \ i=1,\cdots,p
$$
<strong>Slater&rsquo;s theorem</strong> states that
$$
\textrm{Slater's condition holds} \Rightarrow \textrm{Strong duality holds}
$$
i.e., the minimization of origin problem (primal problem) equals to the maximization of (Lagrangian) dual problem, which reads
$$
\begin{aligned}
\textrm{maximize}\indent & g(\lambda, \nu) = \inf_x L(x,\lambda,\nu)\\
\textrm{subject to} \indent & \lambda_i \leq 0 \ , \ i = 1,\cdots,m\\
\end{aligned}
$$
(note that the infimum does not constrain        $x$ )  ,  ) in which
$$
L(x,\lambda,\nu) = f(x) - \sum_{i=1}^m\lambda_i u_i(x) - \sum_{i=1}^p\nu_i v_i(x)
$$
is the Lagrangian of primal problem.</p>
</blockquote>
<p>An important relation between the optimal of primal problem and dual problem is that: if strong duality holds and a dual optimal solution   $(\lambda^*,\nu^ *)$   exists, then   $\forall x \in F=\{x:u_i(x) \leq 0, v_i(x)=0\}: \lambda_i u_i(x) \geq 0, \nu_i v_i(x)=0$ .. Thus</p>
<p>$$
\inf_x L(x,\lambda^ *, \nu^ *) = \min_{x\in F} f(x)\Rightarrow x^ * = \arg\min_ {x\in F} f(x) = \arg\min_ {x} L(x,\lambda^ *,\mu^ *)
$$</p>
<p>That is, solving the dual problem freely gives us the optimal of primal problem.</p>
<p>Now let us consider the optimization problem of SVM training. The objective function   $\|w\|^2/2$   is convex, while the inequality constraints   $1-y_i(w\cdot x_i+b)\leq 0$   are all convex. Thus, we can use Slater&rsquo;s theorem to demonstrate the training has strong duality (Only few support vectors are at the boundary of constraints). The Lagrangian:</p>
<p>$$
\begin{aligned}
L(w,b,\lambda) &= \frac 1 2 \|w\|^2 - \sum_{i=1}^N\lambda_i (1-y_i(w\cdot x_i+b)) \\
\Rightarrow g(\lambda) &= \inf_{w\in \mathbb{R}^d, b\in \mathbb{R}}L(w,b,\lambda) = -\sum_{i=1}^N \lambda_i - \frac 1 2 \sum_{i,j=1}^N \lambda_i\lambda_j y_iy_j (x_i\cdot x_j)
\end{aligned}
$$</p>
<p>in which we optimize of quadratic from of   $L(w,b,\lambda)$   with respect to    $w,b$    by</p>
<p>$$
\begin{aligned}
\frac {\partial L} {\partial w}\Bigg|_{w=w^*} = 0 &\Rightarrow w^ * = -\sum_{i=1}^N \lambda_i y_i x_i \\
\frac {\partial L} {\partial b}\Bigg|_{b=b^*} = 0 &\Rightarrow 0 = \sum_{i=1}^N \lambda_i y_i
\end{aligned}
$$</p>
<p>Then, primal optimization problem now transforms as dual problem:</p>
<p>$$
\begin{aligned}
\textrm{maximize} \indent & -\frac 1 2 \lambda^T \bm{K} \lambda - \bm{1}^T \lambda \\
\textrm{subject to} \indent & \lambda_i \leq 0 \ , \ i=1,\cdots,N \\
& y \cdot \lambda = 0
\end{aligned}
$$</p>
<p>in which,   $(\bm{K})_{i,j} = y_i y_j (x_i\cdot x_j)$ ,,   $y=(y_1,\cdots,y_N)^T$ ,, and   $\bm{1}=(1,\cdots,1)^T$ 
</p>
<p>The time complexity of classical training is made up with the following three steps:</p>
<ol>
<li>  $\mathcal{O}(N^2d)$ .. Construction of the dual problem:   $\mathcal{O}(N^2)$   times inner product for    $d$ ---vectors</li>
<li>   $\mathcal{O}(N^3)$  .. For the convex quadratic programming.</li>
<li>  $\mathcal{O}(Nd)$ .. For the recovery of    $w,b$    from dual optimal.</li>
</ol>
<p>Thus, the total time complexity is of   $\mathcal{O}(N^2(d+ N))$ .. The reason why use dual form but not primal form is to be capable to kernel tricks: replace   $x_i\cdot x_j$   into   $k(x_i,x_j)$   for nonlinear support.</p>
</details>
<p>In (<a href="https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.113.130503">P. Rebentrost 2014</a>), the quantum speedup of SVM for big data classification is introduced. They use the <strong>least squares support vector machine</strong> introduced in (<a href="https://rd.springer.com/article/10.1023%2FA%3A1018628609742">J.A.K. Suykens 1999</a>), in which the model is trained by solving a linear system instead of a convex quadratic programming. The training (together with kernel trick) reads:</p>
<p>$$
\begin{aligned}
\textrm{minimize} \indent & \frac 1 2 \|w\|^2 + \frac 1 2 \gamma\sum_{i=1}^N e_i^2 \\
\textrm{subject to} \indent & w\cdot \phi(x_i)+b= (1 - e_i)y_i \ , \ i=1,\cdots,N 
\end{aligned}
$$</p>
<p>Such optimization problem with equality constraints can be solved by</p>
<p>$$
\begin{aligned}
\begin{cases}
\partial_w L =0 & \Rightarrow w = -\sum_{i=1}^N \lambda_i \phi(x_i)\\
\partial_b L =0 & \Rightarrow 0 = \sum_{i=1}^N \lambda_i \\
\partial_e L = 0 &\Rightarrow \lambda_i y_i = -\gamma e_i \\
\partial_\lambda L = 0 &\Rightarrow w\cdot \phi(x_i) + b = y_i-e_iy_i 
\end{cases}
& \Rightarrow
\begin{bmatrix}
\bm{I} & 0 & 0 & \bm Z \\
0 & 0 & 0 &\bm{1}^T \\
0 & 0 & \gamma \bm I & \textrm{diag}\bm{Y} \\
\bm{Z}^T & \bm{1} & \textrm{diag}\bm{Y} & 0
\end{bmatrix} \begin{bmatrix} w \\ b \\ e \\ \lambda \end{bmatrix} = \begin{bmatrix} 0 \\ 0 \\ 0 \\ y \end{bmatrix} \\
&\Rightarrow 
\begin{bmatrix}
0 & \bm{1}^T \\
\bm{1} & -\gamma^{-1}\bm{I} - \bm{K}
\end{bmatrix} \begin{bmatrix}b \\ \lambda\end{bmatrix} = \begin{bmatrix} 0 \\ y\end{bmatrix} \\
&\Rightarrow
\bm{F} \begin{bmatrix}b \\ \lambda\end{bmatrix} = \begin{bmatrix} 0 \\ y\end{bmatrix}
\end{aligned}
$$</p>
<p>in which   $\bm{Z} = [\phi(x_1),\cdots, \phi(x_N)]$ ,,   $\textrm{diag}\bm{Y}=\textrm{diag} \{ y_1,\cdots,y_N \}$ ,, and   $\bm{K} = \bm{Z}^T \bm{Z}\Rightarrow (\bm{K})_{ij} = \phi(x_i)\cdot \phi(x_j) = k(x_i,x_j)$   is the kernel matrix, when kernel trick is disabled,    $k(x_i,x_j)=x_i\cdot x_j$ ,.. Solving this linear system has time complexity    $\mathcal{O}(N^3)$  . (or   $\mathcal{O}(N^{2.3})$   for sparse coefficient matrix (<a href="https://www.sciencedirect.com/science/article/pii/S0747717108800132?via%3Dihub">D. Coppersmith 1990</a>)).</p>
<p>The quantum SVM use HHL algorithm to find the solution of above linear system in a normalized form as   $\hat F \ket{b,\lambda} = \ket{y}$ ,, in which with the encoding   $\bra{i}\hat F\ket{j} = (\bm{F}/\textrm{Tr}\bm{F})_{ij}$ ,,   $\ket{y}=\sum_{i=1}^N y_i\ket{i}$ ,, and   $\ket{b,\lambda} = b\ket{0} + \sum_{i=1}^N \lambda_i \ket{i}$ .. It would not influence the prediction because the sign of   $w \cdot x +b$   is invariant by zooming    $w, b$    (or   $\lambda, b$ )) with the same factor. As shown below, the time complexity of training a quantum SVM is   $\tilde{\mathcal{O}}(\log N)$ ..</p>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Simulate quantum evolution driven by   $\hat F$ "
    </summary>
<p>To implement HHL algorithm, we need simulate the unitary operator   $e^{\ti \Delta t \hat F}$    efficiently. The second order approximation reads</p>
<p>$$
\bra{i}e^{\ti \Delta t \hat F}\ket{j} = e^{\ti \Delta t \bm{J}/\textrm{Tr}\bm{F}} \begin{bmatrix} 1 & 0 \\ 0 & e^{-\ti \gamma \Delta t /\textrm{Tr}\bm{F}} \bm{I} \end{bmatrix} \begin{bmatrix} 1 & 0 \\ 0 & e^{-\ti \Delta t \bm{K}/\textrm{Tr}\bm{F}}\end{bmatrix} + \mathcal{O}(\Delta t^2)
$$</p>
<p>in which</p>
<p>$$
\bm{J} = \begin{bmatrix} 0 & \bm{1}^T \\ \bm{1} & \bm{0}\end{bmatrix}
$$</p>
<p>The evolution driven by    $\bm{J}$    is straightforward. There are only two nonzero eigenvalues and the corresponding eigenvectors are</p>
<p>$$
\hat J \ket{J_{\pm}} \equiv \Big(\sum_{i=1}^N \ket{0}\bra{i} + \ket{i}\bra{0}\Big)\ket{J_{\pm}} = \pm\sqrt{N} \times \frac 1 {\sqrt{2}}\big(\ket{0} \pm \frac 1 {\sqrt{N}} \sum_{i=1}^N \ket{i}\big)
$$</p>
<p>The basis transformation to diagonalize matrix   $\hat J$   can be achieved by the following strategy</p>
<p>$$
[\ket{0}, \ket{1},\cdots,\ket{N}]\rightarrow[\ket{0}, \ket{1},\cdots,\ket{N}]
\left[
\begin{array}{cc|ccc}
1 & 0 & & & \\
\hline
0 & 1/\sqrt{N} & & & \\
\vdots & \vdots & & \bm{R} & \\
0 & 1/\sqrt{N} & & & 
\end{array}
\right]
\begin{bmatrix}
\bm{H} & \\
& \bm{I} 
\end{bmatrix}
$$</p>
<p>in which   $\bm{R}$   makes the first transformation unitary,   $\bm{H}$   is a Hadamard gate for    $\ket{0}, \ket{1}$    subspace. With the transform the evolution driven by    $\bm{J}$    can be simulated.</p>
<p>The evolution driven by   $\gamma^{-1} \bm{I}$   is trivial, now let us consider how to simulate the evolution driven by   $\bm{K}$ .. With qRAM, one can prepare the state of (by two-level addressing)</p>
<p>$$
\ket{x} = \frac 1 {\sqrt{N}} \sum_{i=1}^N \ket{i}\ket{x_i}
$$</p>
<p>with   $\ket{x_i} =\|x_i\|^{-1}\sum_{r=1}^d x_i^r\ket{r}$ .. Then with the controlled rotation, we can make it to be (like we did in state preparation by qRAM, but now we encode   $\|x_i\|$   instead of   $x_i^r$ .. If the norm of each data is stored in qRAM, this procedure is also efficient.)</p>
<p>$$
\ket{x} = \frac 1 {\sqrt{\sum_{i=1}^N \|x_i\|^2}} \sum_{i=1}^N \|x_i\| \ket{i}\ket{x_i}
$$</p>
<p>Now, if we discard the dataset register, i.e., partially trace out those    $d$ ---dimensional kets, we obtain the kernel matrix as a density matrix</p>
<p>$$
\hat \rho = \textrm{Tr}_2 \ket{x}\bra{x} = \frac 1 {\sum_{i=1}^N \|x_i\|^2} \sum_{i,j=1}^N \braket{x_i|x_j} \|x_i\|\|x_j\| \ket{i}\bra{j}
$$</p>
<p>If the kernel function    $k(x_i,x_j)=x_i\cdot x_j$ ,., then it is the value of   $\braket{x_i|x_j}\|x_i\|\|x_j\|$ .. With tensor encoding by   $\ket{\phi(x_i)} = \ket{x_i}^{\otimes l}$ ,, the coefficients are   $\braket{\phi(x_i)|\phi(x_j)} = (\bra{x_i}x_j\rangle)^l$ .. Thus with this trick, one can prepare any polynomial kernel matrix.</p>
<p>Now we have the kernel matrix as   $\hat \rho = \hat K / \textrm{Tr}\bm{K}$ .. Since   $\textrm{Tr}\bm{K}/\textrm{Tr}\bm{F} \sim \mathcal{O}(1)$ ,, this time factor would not hurt the efficiency of algorithm. The trace of kernel matrix can be simply estimated by the following procedure:</p>
<ol>
<li>
<p>Generate the Hamiltonian   $\hat H = \sum_{j=1}^N \|x_j\| \ket{j}\bra{j}\otimes \sigma_x$   by qRAM.</p>
</li>
<li>
<p>Appling   $e^{-\ti \hat H t}$   to the state   $\ket{\psi}=\frac 1 {\sqrt{N}} \sum_{j=1}^N \ket{j}\ket{0}$ .. This results in</p>
<p>$$
    \ket{\psi(t)} = \frac 1 {\sqrt{N}}\sum_{j=1}^N \Big(\cos (\|x_j\|t)\ket{j}\ket{0} -\ti \sin(\|x_j\|t)\ket{j}\ket{0} \Big)
    $$</p>
<p>When   $t$   is small enough, the probability to measure the ancilla qubit in   $\ket{1}$   is   $\frac 1 N \sum_{j=1}^N \|x_j\|^2 t^2$ ,, which allows the estimation of the trace of kernel matrix.</p>
</li>
</ol>
<p>The time evolution driven by           $\hat \rho$ .   .,,   can be done with the following procedure</p>
<p>$$
\begin{aligned}
\textrm{Tr}_1 e^{-\ti \Delta t \hat S} (\hat \rho \otimes \hat \mu) e^{\ti \Delta t \hat S}
&= \hat \mu - \ti \Delta t\textrm{Tr}_1[\hat S, \hat\rho \otimes \hat \mu] + \mathcal{O}(\Delta t^2) \\
&= \hat \mu - \ti \Delta t [\hat \rho, \hat \mu] + \mathcal{O}(\Delta t^2) \\
&\approx e^{-\ti \Delta t \hat \rho} \hat \mu e^{\ti \Delta t\hat \rho} 
\end{aligned}
$$</p>
<p>in which we have   $\hat S = \sum_{m,n=1}^N \ket{m}\bra{n}\otimes \ket{n}\bra{m}$ .. Thus, we can implement the evolution driven by           $\hat \rho$ .   .,,   efficiently. As shown in (<a href="https://link.springer.com/article/10.1007/s00220-006-0150-x">D. Berry 2006</a>), the time complexity is of   $\tilde{\mathcal{O}}(\log N \Delta t)$ .. The bottleneck is the preparation of kernel matrix.</p>
</details>
<p>After the training process, i.e., we obtain the amplitude encoding vector    $\ket{b, \lambda}$  ,, the prediction for a new item    $\ket{x}$  . can be done by following steps:</p>
<ol>
<li>
<p>query the qRAM of training set with addressing register being    $\ket{b, \lambda}$  , then prepare the state of</p>
<p>$$
    \ket{u} \propto b\ket{0}\ket{0} + \sum_{k=1}^N \lambda_k \|x_k\|\ket{k}\ket{x_k}
    $$</p>
</li>
<li>
<p>Prepare the state of new item:</p>
<p>$$
    \ket{\tilde{x}} \propto \ket{0}\ket{0} + \sum_{k=1}^N \|x\| y_k\ket{k}\ket{x}
    $$</p>
</li>
<li>
<p>With an ancilla qubit, prepare the state of (this seems to be a non-trivial process, but it could be efficient on a well-structured qRAM.)</p>
<p>$$
    \frac 1 {\sqrt{2}} \Big(\ket{0}\ket{u} + \ket{1} \ket{\tilde{x}}\Big)
    $$</p>
</li>
<li>
<p>Make a measurement on ancilla qubit with the basis of   $\ket{\pm} = 2^{-1/2}(\ket{0}\pm\ket{1})$ ,, the probability to find   $\ket{+}$   is</p>
<p>$$
    \begin{aligned}
    \mathbb{P}(+) &= \frac {1+\textrm{Re}\braket{u|\tilde{x}}} 2 \\
    \Rightarrow \mathbb{P}(+)-\frac 1 2 &\propto b+\sum_k \lambda_k \|x_k\|\|x\|\braket{x|x_k} \\
    &= b+\sum_k \lambda_k y_k k(x,x_k) \\
    &= b + w \cdot x
    \end{aligned}
    $$</p>
<p>So, the prediction of SVM is   $\textrm{sgn}(\mathbb{P}(+)-1/2)$ ..</p>
</li>
</ol>
<h3 id="quantum-pca">Quantum PCA</h3>
<p><strong>Principal Component Analysis(PCA)</strong> is a typical unsupervised learning algorithm in classical machine learning. For the given dataset   $\{x_i^r\}_{i=1,\cdots,N; r=1,\cdots,d}$ ,, PCA tries to find the principal axes of the ellipsoid determined by the distribution of dataset in   $\mathbb{R}^d$ .. i.e., it finds the directions along which the variance of dataset projection is maximal (<a href="https://en.wikipedia.org/wiki/Principal_component_analysis">Wikipedia/Principal_component_analysis</a>). Formally, the output of PCA is the solution of the following optimization problem</p>
<p>$$
\begin{aligned}
\textrm{maximize} \indent & \Big((x_i - \frac 1 N \sum_{i=1}^N x_i) \cdot w\Big)^2 \\
\textrm{subject to} \indent & w \in \mathbb{R}^d \\
& \|w\| = 1
\end{aligned}
$$</p>
<p>It can be reduced into an eigensystem problem, with omitting the principal components whose eigenvalues (variance along them) are below the threshold, PCA can also be applied for dimensionality reduction and low-rank approximation.</p>
<p>In 2014, S. Lloyd et al proposed the quantum version of PCA (<a href="https://www.nature.com/articles/nphys3029.pdf">S. Lloyd 2014</a>). The algorithm is based on the HHL algorithm for matrix inversion, thus authors claim their algorithm is exponentially faster than classical case. (but it still sufferes the caveats of HHL algorithm).</p>
<p>The algorithm begins with a pure quantum way, different from SVM, qRAM is optional for qPCA. We follow the paper (<a href="https://www.nature.com/articles/nphys3029.pdf">S. Lloyd 2014</a>), the relation between qPCA and classical case will be discussed at the end of this part. Given        $n$  -  -- copies of quantum state           $\hat \rho$ .   .,,  , with the similar strategy in SVM, we can simulate the time evolution of</p>
<p>$$
\hat \mu(t) = e^{-\ti \hat \rho t} \hat \mu(0) e^{\ti \hat \rho t}
$$</p>
<p>efficiently. Thus, with the controlled time evolution and phase estimation, we can prepare the state of (with spectrum decomposition of   $\hat \rho = \sum_{i=1}^{\mathcal{D}} p_i \ket{\chi_i}\bra{\chi_i}$ )):</p>
<p>$$
\begin{aligned}
\sum_t \ket{t}\otimes e^{-\ti \hat \rho t}\ket{\psi} &\rightarrow \sum_{\omega} \ket{\omega} \delta_{\omega,p_i}\otimes \sum_{i=1}^{\mathcal{D}} \ket{\chi_i}\bra{\chi_i}\psi\rangle \\
&\rightarrow \sum_{i=1}^{\mathcal{D}} \ket{p_i}\otimes \ket{\chi_i}\bra{\chi_i}\psi\rangle
\end{aligned}
$$</p>
<p>Apply this subroutine on initial state of           $\hat \rho$ .   .,,  , together with the controlled rotation, we actually achieve the state of</p>
<p>$$
\sum_{i=1}^{\mathcal{D}} p_i \ket{p_i}\bra{p_i}\otimes \ket{\chi_i}\bra{\chi_i} 
$$</p>
<p>The first part is the register storing the eigenvalue of           $\hat \rho$ .   .,,  . As an encapsulation, qPCA allows us to reach the map</p>
<p>$$
\hat \rho \otimes \ket{0}\bra{0} \xrightarrow{\textrm{qPCA}} \sum_{i=1}^{\mathcal{D}} p_i \ket{i}\bra{i}\otimes \ket{p_i}\bra{p_i}
$$</p>
<p>within exponentially short time complexity than classical case, if the number of copies of           $\hat \rho$ .   .,,   is enough (polynomially dependent of the precision requirement).</p>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Implement qPCA on classical dataset 
    </summary>
<p>For classical dataset, qPCA requires qRAM to load data and encode them into amplitude efficiently. When the center-shifted data (i.e.,   $\sum_{i=1}^N x_i = 0$ )) is loaded as</p>
<p>$$
\frac 1 {\sqrt{N}} \sum_{r=1}^d \frac 1 {\|x^r\|} \sum_{i=1}^N x_i^r \ket{i}\ket{r} \xrightarrow[\textrm{post selection}]{\textrm{ancilla rotation}} \ket{D} = \frac 1 {\sqrt{\sum_{r=1}^d \|x^r\|^2}} \sum_{r=1}^d \|x^r\|\ket{r}\ket{x^r} 
$$</p>
<p>where   $\ket{x^r} = \|x^r\|^{-1} \sum_{i=1}^N x_i^r\ket{i}$   and   $\|x^r\|=\sum_{i=1}^N (x_i^r)^2$ .. Then by controlled rotation and partial trace (like we did in SVM, but here we exchange the indices of data entry and feature index), we can prepare the state of:</p>
<p>$$
\hat \rho = \textrm{Tr}_1 \ket{D}\bra{D} = \frac 1 {\sum_{r=1}^d \|x^r\|^2} \sum_{r,r'=1}^d \ket{r} (\sum_{i=1}^N x_i^r x_i^{r'})\bra{r'}
$$</p>
<p>Thus, use this state as the initial state of qPCA, we can implement the qPCA for classical data.</p>
</details>
<p>In a recent paper (<a href="https://journals.aps.org/prl/pdf/10.1103/PhysRevLett.126.110502">T. Xin 2021</a>), an experimental protocol for quantum PCA has been proposed. Different from the above algorithm to find an approach for general density matrix, they use parameterized quantum circuit to find the decomposition for a fixed matrix by training set. With such variational and hybrid classical quantum approach, they claim their protocol could work well on near-term quantum device.</p>
<p>The goal of their qPCA is to find the diagonalization of the given matrix   $\hat \rho = \sum_{i=1}^{\mathcal{D}} p_i \ket{\psi_i}\bra{\psi_i}$   where   $\ket{\psi_i}$   mutually orthogonal and   $p_1\geq p_2\geq \cdots \geq p_{\mathcal{D}}$ ,, i.e.</p>
<p>$$
\hat U \hat \rho \hat U^\dagger = \sum_{i=1}^{\mathcal{D}} p_i \ket{i}\bra{i}
$$</p>
<p>The theoretical support is:</p>
<p><em>[Theorem]</em> : Given a semidefinite positive and non-degenerate Hermitian operator   $\hat A = \sum_{j=1}^{\mathcal{D}} \lambda_j \ket{j}\bra{j}$   with   $\ket{j}$   the eigenstate with eigenvalue   $\lambda_j$ ,, assuming   $0\leq \lambda_1\lt \lambda_2\lt\cdots\lt \lambda_{\mathcal{D}}$   and   $\sum_{j=1}^{\mathcal{D}} \lambda_j = 1$ .. One example is   $\hat A = \frac 1 {N(N-1)} \sum_{j=1}^{\mathcal{D}} 2^{j-1} (\hat Z_j+1)$   in which   $\hat Z_j$   is Pauli-- $Z$   at   $j$ --th site. Then the solution of the following optimization problem</p>
<p>$$
\begin{aligned}
\textrm{minimize} \indent & \textrm{Tr} (\hat U \hat \rho \hat U^\dagger \hat A) \\
\textrm{subject to} \indent & \hat U^\dagger \hat U = \hat 1
\end{aligned}
$$</p>
<p>would diagonalize           $\hat \rho$ .   .,,   in the computational basis, i.e.,   $\hat U \hat \rho \hat U^\dagger = \sum_{i=1}^{\mathcal{D}} p_i\ket{i}\bra{i}$ ..</p>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Proof
    </summary>
<p>Given objection function</p>
<p>$$
\begin{aligned}
L(\hat U) &= \textrm{Tr} (\hat U\hat \rho \hat U^\dagger \hat A)\\
&= \sum_{i,j=1}^{\mathcal{D}} p_i \lambda_j \big|\bra{\psi_i}\hat U^\dagger \ket{j}\big|^2 \\
&= \bm{p}^T \bm{\Pi}\bm{\lambda}
\end{aligned}
$$</p>
<p>where   $\bm{p}^T = (p_1,\cdots,p_{\mathcal{D}}), \bm{\lambda}^T=(\lambda_1,\cdots,\lambda_{\mathcal{D}})$ ,, and   $(\bm{\Pi})_{ij} = \big|\bra{\psi_i}\hat U^\dagger\ket{j}\big|^2$ .. By Birkhoff-von Neumann decomposition (<a href="https://en.wikipedia.org/wiki/Doubly_stochastic_matrix">Wikipedia/Doubly_stochastic_matrix</a>), such matrix can be write as the weighted average of a set of permutation matrix. i.e.,</p>
<p>$$
\bm{\Pi} = \sum_{l=1}^k \theta_l \bm{P}_l
$$</p>
<p>in which   $\bm{P}_l$   are permutation matrix, and   $\theta_l\geq 0, \sum_{l=1}^k \theta_l=1$ .. Then with rearrangement iequality:</p>
<p>$$
x_1\leq x_2\leq\cdots\leq x_n\textrm{ and } y_1\leq \cdots y_n \Rightarrow \sum_{k=1}^n x_k y_{n+1-k} \leq \sum_{k=1}^n x_k y_{\sigma(k)} \leq \sum_{k=1}^n x_k y_k
$$</p>
<p>we have:</p>
<p>$$
L(\hat U) = \bm{p}^T \bm{\Pi}\bm{\lambda} = \sum_{l=1}^k\theta_l \bm{p}^T \bm{P}_l\bm{\lambda} \geq \bm{p}^T \bm{\lambda}
$$</p>
<p>Note that with the protocol,    $\bm{\lambda}$    and   $\bm{p}$   have the reverted order. And this lower bound is compact. With the condition that    $\bm{\lambda}$    is non-degenerate, if           $\hat \rho$ .   .,,   is also non-degenerate, the solution should be unique such that   $\bra{\psi_i}\hat U^\dagger \ket{j} = \delta_{ij}$   holds. Otherwise, the permutation or re-combination in degenerated subspace is allowed, but it does not hurt the spectrum decomposition of           $\hat \rho$ .   .,,  . The theorem gets proved.</p>
</details>
<p>The qPCA via VQC (variational quantum circuit) is to minimize the objection function</p>
<p>$$
L(\bm{z}) = \textrm{Tr}(\hat U(\bm{z})\hat \rho \hat U(\bm{z})^\dagger \hat A)
$$</p>
<p>with the parameterized circuit   $\hat U(\bm{z})$   by gradient descent. In their main text, they used three different type circuits to implement the algorithm.</p>
<details>
    <summary style="background-color:#f5f5f5;border:1px solid #ccc;padding:5px;">
        Fast-grad for VQC
    </summary>
<p>In the paper, they used the VQC of form</p>
<p>$$
\hat U(\bm{z}) = \prod_{l\in \textrm{Layers}} \Big(\prod_i \prod_{j\in F_i} \textrm{CNOT}_{i,j} \prod_i e^{\ti z_i \sigma^y_i}\Big)
$$</p>
<p>in which set   $F_i$   denotes the qubits connected to   $i$ --th qubit with   $\textrm{CNOT}$   gate. This type can be easily to compute the gradient, with the property that:</p>
<p>$$
\hat H^2 = \hat 1 \Rightarrow [\hat H, \hat O] = \ti\Big(e^{-\ti \hat H \pi/4}\hat O e^{\ti \hat H \pi/4} - e^{\ti\hat H \pi/4} \hat O e^{-\ti \hat H \pi/4}\Big)
$$</p>
<p>This can be proved by noticing   $e^{-\ti \phi \hat H} = \cos\phi -\ti \sin \phi \hat H$ 
</p>
<p>$$
\begin{aligned}
\textrm{r.h.s.} &=\ti\Big(e^{-\ti \hat H \pi/4}\hat O e^{\ti \hat H \pi/4} - e^{\ti\hat H \pi/4} \hat O e^{-\ti \hat H \pi/4}\Big)  \\
&=\ti\Big((\frac {\sqrt{2}} 2 - \ti \frac {\sqrt{2}} 2\hat H) \hat O (\frac {\sqrt{2}} 2 + \ti \frac {\sqrt{2}} 2\hat H) - (\frac {\sqrt{2}} 2 + \ti \frac {\sqrt{2}} 2\hat H)\hat O(\frac {\sqrt{2}} 2 - \ti \frac {\sqrt{2}} 2\hat H)\Big) \\
&=\ti\Big(- \frac \ti 2 \hat H \hat O + \frac \ti 2 \hat O \hat H + \text{c.c.}\Big) \\
&=[\hat H, \hat O] = \textrm{l.h.s.}
\end{aligned}
$$</p>
<p>Thus, the gradient of objection with   $F(\bm{z}) = \braket{\hat U^\dagger(\bm{z}) \hat O \hat U(\bm{z})}$   is</p>
<p>$$
\begin{aligned}
\partial_j F(\bm{z}) &= \Big\langle\prod_{k=1}^{j-1}\hat U_k^\dagger(z_k) \partial_z \hat U_j^\dagger (z_j)\prod_{k=j+1}^K \hat U_k^\dagger(z_k) \hat O \hat U(\bm{z})\Big\rangle + \Big\langle\hat U^\dagger(\bm{z}) \hat O\prod_{k=j+1}^K \hat U_k^\dagger(z_k)\partial_z \hat U_j^\dagger (z_j)\prod_{k=1}^{j-1}\hat U_k^\dagger(z_k)  \Big\rangle \\
&=-\ti \langle \hat U^\dagger_{1\rightarrow j-1} [\hat H_j, \hat U^\dagger_{j\rightarrow K}\hat O \hat U_{K\rightarrow j}] \hat U_{j-1\rightarrow 1}\rangle \\
&=\langle \hat U^\dagger_{1\rightarrow j-1} \hat U^\dagger_j(\pi/4)\hat U^\dagger_{j\rightarrow K}\hat O \hat U_{K\rightarrow j}\hat U_j(\pi/4)  \hat U_{j-1\rightarrow 1} \rangle - (\pi/4\leftrightarrow -\pi/4) \\
&= F(z_j + \pi/4) - F(z_j-\pi/4)
\end{aligned} 
$$</p>
<p>Thus, the gradient can be obtained efficiently.</p>
</details>

          
          </div>

          
          <div class="row">
            <div class="col-md-8">
            
              <div class="mb-5">
                
<div class="li-x div-x post-meta">
  <li class="pr-0"><a href="https://wzdlc1996.github.io/tags/"><i class="fas fa-tags"></i></a></li>
  <div class="tags-sm">
    
      <li><a href="https://wzdlc1996.github.io/tags/quantum" role="button">quantum </a></li>
      
    
  </div>
</div>
              </div>
            
            </div>
            
          </div>
          

          
          <div class="row pt-3">
            <div class="col-md-6">
              
                <a href=https://wzdlc1996.github.io/artic/physics/ctcquantcomputing/ class="post-meta">Previous
                  <div class="pt-2 pb-5 d-flex">
                    <i class="fas fa-angle-left text-grey font-weight-bold mr-2 active-color"></i>
                    <span>Time Travel and Quantum Computation</span>
                  </div>
                </a>
              
            </div>
            
            <div class="col-md-6 text-right" >
              
                <a href=https://wzdlc1996.github.io/artic/physics/numschrodinger/ class="post-meta">Next
                  <div class="pt-2 pb-5 flex-reverse">
                    <i class="fas fa-angle-right text-grey font-weight-bold ml-2 active-color"></i>
                    <span>Numerical Methods for Schrodinger Equation</span>
                  </div>
                </a>
              
            </div>
          </div>

          

        </div>
        

      </div>
      

      
	
	
	
	
		
		
		
	

		
		<div class="col-md-2 pl-0">

			
			<div id="page-scrollspy" class="toc-nav">
				
				<ul class="nav nav-pills ml-0">
					
					<li class="nav-item pb-3 text-center">
						<span class="font-weight-bold mb-2">- CATALOG - </span>
					</li>

					
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#data-science-and-machine-learning">
												 Data Science and Machine Learning
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#quantum-tech-to-data-science">
												 Quantum Tech to Data Science
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#quantum-speedup-for-classical-machine-learning">
												 Quantum Speedup for Classical Machine Learning
											</a>
										</li>
						 
								
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#essential-techs-for-applied-quantum-computing">
												 Essential Techs for Applied Quantum Computing
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#data-loader-qram">
												 Data Loader: qRAM
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#quantum-linear-algebra">
												 Quantum Linear Algebra
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#quantum-machine-learning-algorithms">
												 Quantum Machine Learning Algorithms
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#quantum-svm">
												 Quantum SVM
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 
						
						
							
								
								
									<ul class="nav">
								
									<ul class="nav">
								
									<ul class="nav">
								
								

										<li class="nav-item">
						 					<a class="nav-link" href="#quantum-pca">
												 Quantum PCA
											</a>
										</li>
						 
								
								
									</ul>
								
									</ul>
								
									</ul>
								
							
						
				 

				</ul>
			</div>
			

		</div>
		
	

    </div>
    


  </main>
  


    
    

<footer class="page-footer text-center font-small mt-4 wow fadeIn">


  
  <div class="pb-2 mt-5 pt-5">
    
      <a href="http://github.com/wzdlc1996 " target="_blank" rel="noopener"><i class="fab fa-github mr-3" aria-hidden="true"></i></a>
    
    

    

    

    

    

    


    
        <a href="mailto:wzdlc1996@gmail.com"><i class="far fa-envelope-open mr-3" aria-hidden="true"></i></a>
    

    

    

  </div>
  

  
  <div class="copyright py-4">
    
    <span>  2016 - 2022 &copy; | Theme <a href='https://github.com/orianna-zzo/AllinOne' target="_blank">AllinOne</a> by <a href='https://github.com/orianna-zzo' target="_blank">Orianna</a>  </span>
  </div>
  

</footer>


    






<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors/jquery/jquery-3.3.1.min.js"></script>
<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors/jquery/jquery.smooth-scroll.min.js"></script>



<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors/popper.min.js"></script>
<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors/holder.min.js"></script>
<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors-extensions/bootstrap4/bootstrap.js" ></script>

<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors/mdb/mdb.min.js"></script>



<script type="text/javascript" src="https://wzdlc1996.github.io/js/vendors/lightbox/lightbox.min.js"></script>
<script type="text/javascript">
(function () {
  var imgList = document.getElementsByTagName("img");
  var imgLen = imgList.length;
  for (var i = 0; i < imgLen; i++) {
    if (!(imgList[i].parentElement
                    .classList
                    .contains("mainTextImg"))) {
      continue;
    }
    imgList[i].id = "imgtmp" + i;
    var imgtmp = document.getElementById("imgtmp" + i);
    imgtmp.style.height="400px";
    var a = document.createElement("a");
    imgtmp.parentNode.replaceChild(a, imgtmp);
    a.href = imgtmp.src;
    a.rel = "lightbox";
    a.appendChild(imgtmp);
  }
}());
</script>




<script type="text/javascript" src="https://wzdlc1996.github.io/js/main.js"></script>




  <script src="https://wzdlc1996.github.io/js/vendors/highlight.pack.js"> </script>
  <script>hljs.initHighlightingOnLoad();</script>





  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$']],
      displayMath: [["$$", "$$"]],
      macros: {
        bm: ["{\\boldsymbol {#1}}",1],
        flo: ["\\overset {\\cdot} {#1}",1],
        td: ["\\text{d}"],
        ti: ["\\text{i}"],
        bra: ["{\\langle #1 |}",1],
        ket: ["{| #1 \\rangle}",1],
        degree: ["{^\{\\circ\}}",0],
        indent:["\\ \\ \\ \\ ",0],
        rhat: ["\\overset {\\rightarrow} {#1}",1],
        lhat: ["\\overset {\\leftarrow} {#1}",1],
        lrhat: ["\\overset {\\leftrightarrow} {#1}",1]
      },
      processEscape: true
    }

  }
</script>








<script type="text/javascript">
  
  new WOW().init();
</script>

  </body>
</html>